/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/9.1.0/userguide/building_java_projects.html in the Gradle documentation.
 * This project uses @Incubating APIs which are subject to change.
 */

plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    id 'application'
    id 'java'
    id 'org.springframework.boot' version '3.2.5'
}

apply plugin: 'io.spring.dependency-management'

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

dependencies {
    // This dependency is used by the application.
    implementation libs.guava
    implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-hateoas'
    runtimeOnly 'com.h2database:h2'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

testing {
    suites {
        // Configure the built-in test suite
        test {
            // Use JUnit Jupiter test framework
            useJUnitJupiter()
        }
    }
}

sourceSets {
    integrationTest {
        java {
            srcDir 'src/integrationTest/java'
        }
        resources {
            srcDir 'src/integrationTest/resources'
        }

        compileClasspath += sourceSets.main.output
        runtimeClasspath += sourceSets.main.output
    }
}


configurations {
    integrationTestImplementation.extendsFrom implementation
    integrationTestRuntimeOnly.extendsFrom runtimeOnly
}

dependencies {
    integrationTestImplementation 'org.springframework.boot:spring-boot-starter-test'
    integrationTestRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    integrationTestRuntimeOnly 'com.h2database:h2'
}

task integrationTest (type: Test){
    description = 'Executa testes de integração'
    group = 'COGSI'
    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    shouldRunAfter test
    useJUnitPlatform()
}

check.dependsOn integrationTest


// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

application {
    // Define the main class for the application.
    mainClass = 'payroll.PayrollApplication'
}

// Issue #32 - deployToDev: cleans build/deployment/dev and prepares artifacts for a dev deployment
def devDeployDir = "$buildDir/deployment/dev"

tasks.register('cleanDevDeploy', Delete) {
    group = 'DevOps'
    description = 'Cleans the build/deployment/dev directory'
    delete devDeployDir
}

tasks.register('copyAppArtifact', Copy) {
    group = 'DevOps'
    description = 'Copies the main application artifact (JAR) to build/deployment/dev'
    dependsOn tasks.named('jar')
    mustRunAfter 'cleanDevDeploy'
    from(tasks.named('jar').flatMap { it.archiveFile })
    into devDeployDir
}

tasks.register('copyRuntimeLibs', Copy) {
    group = 'DevOps'
    description = 'Copies only runtime dependency JARs to build/deployment/dev/lib'
    mustRunAfter 'cleanDevDeploy'
    from({ configurations.runtimeClasspath.filter { it.name.endsWith('.jar') } })
    into "$devDeployDir/lib"
}

tasks.register('copyConfigWithTokens', Copy) {
    group = 'DevOps'
    description = 'Copies .properties to build/deployment/dev with ReplaceTokens (projectVersion, buildTimestamp)'
    mustRunAfter 'cleanDevDeploy'
    // Build timestamp in ISO-8601-like format
    def ts = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ").format(new Date())
    from('src/main/resources') {
        include '*.properties'
        // Use Ant ReplaceTokens; tokens are referenced in files like @projectVersion@, @buildTimestamp@
        filter(org.apache.tools.ant.filters.ReplaceTokens, tokens: [projectVersion: project.version.toString(), buildTimestamp: ts])
    }
    into devDeployDir
}

tasks.register('deployToDev') {
    group = 'DevOps'
    description = 'Cleans build/deployment/dev and copies app jar, runtime libs, and token-filtered configs'
    dependsOn 'cleanDevDeploy', 'copyAppArtifact', 'copyRuntimeLibs', 'copyConfigWithTokens'
}

tasks.register('runApp', Exec) {
    group = 'COGSI'
    description = 'Runs the Chat Application'
    dependsOn tasks.named('installDist')
    
    def os = System.getProperty('os.name').toLowerCase()
    if (os.contains('win')) {
        commandLine "${buildDir}/install/app/bin/app.bat"
    } else {
        commandLine "${buildDir}/install/app/bin/app"
    }
    
}
javadoc {
    group = 'Documentation'
    description = 'Generates Javadoc for the main source set.'
    source = sourceSets.main.allJava
    destinationDir = file("${buildDir}/docs/javadoc")
    classpath = configurations.compileClasspath

    options {
        // Includes classes with package-level visibility in the Javadoc, preventing only PayrollApplication from being documented.
        memberLevel = JavadocMemberLevel.PACKAGE
    }
}

tasks.register('zipJavadoc', Zip) {
    group = 'Distribution'
    description = 'Zips the generated Javadoc documentation.'

    dependsOn tasks.named('javadoc')

    from(tasks.named('javadoc').get().destinationDir)
    archiveFileName = "${project.name}-javadoc-${project.version}.zip"
    destinationDirectory = file("${buildDir}/docs")
}
